n = int(input())

dp =[0] * (n+1)

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1
    if(i % 3 == 0):
        dp[i] = min(dp[i], dp[i//3]+1)
    if(i % 2 == 0):
        dp[i] = min(dp[i], dp[i//2]+1)
        
print(dp[n])

'''
어떤 수 n을

1. 3으로 나누기
2. 2로 나누기
3. -1하기

이 세가지 방법 중 하나를 택해서 반복해 1로 만드는데 필요한 연산의 최솟값을 구하는 문제이다.

처음 문제를 보고 DP를 이용해야겠다고는 생각했는데, 아직 DP가 익숙하지 않다보니 어떻게 구현할지 몰라서 많이 헷갈렸다.
내가 처음 짠 코드이다.



n = int(input())
count = 0
dp = {1:0,2:1, 3:1,4:2,5:3,6:2,7:3,8:3,9:2,10:3}
if(n>10):
    while(n>1):
        for i in range(10,1,-1):
            if(n % i == 0):
                count = count + dp[i]
                n = n // i
                break
            if(i == 2):
                count += 1
                n = n - 1
    print(count)
else:
    print(dp[n])



딕셔너리에 1~10까지의 값을 미리 저장해놓고 10부터 차례로 줄여가며 숫자를 작게 만드는 방법을 택했었다.
하지만 이는 연산의 횟수는 찾을 수 있었지만 최솟값을 찾기에는 역부족이였다.

도저히 어떻게 푸는지 모르겠어서 인터넷을 통해 처음의 코드를 알게 되었다.

처음에 빈 배열로 n크기의 배열을 선언하고,
2와 3으로 나누어 떨어지지 않는 수는 이전 값 + 1을 하여 초기화 시켜준다.

만약 숫자가 3으로 떨어지거나 2로 떨어지면 현재의 값과 이전 3으로 떨어진 값 + 1 을 비교해 초기화 시킨다.
이렇게하면 상향식으로 처음부터 n까지의 값이 정해진다.

다음은 내가 구글링을 하며 DP에 대해 추가로 얻은 정보이다.

DP에는 상향식과 하향식이 있는데, 이 문제에서는 처음 두수(2,3)을 알기 때문에 상향식으로 문제를 푸는 것이 효과적이다.

상향식은 제일 작은 값부터 목표값까지의 값을 찾는 것이고, 
하향식은 맨위의 값에서 '재귀'방식으로 가장 작은 인덱스를 향하는 것이다.

이 문제에서는 변수(2와 3으로 나누어 떨어지지 않을 시, -1을 하는 것)이 있기 때문에 그리디 알고리즘을 적용시키지 못한다.
그리디 알고리즘은 내가 생각한 처음 최적의 방법이 끝까지 반례 없이 적용이 되는 경우에 이용하고,
동적 계획법은 가능성을 모두 두고 그 안에 최솟값을 찾을 수 있기 때문에 그리디와 브루트포스의 중간 같은 느낌이다.

한 예로, 위의 문제 기준으로 
그리디로 문제를 푼다면 당연히 큰 수로 처음부터 계속 나누는 것이 제일 빨리 1로 도달할 수 있을 것이다.

하지만, 10의 경우엔 10 - 5 - 4 - 2 - 1로 푸는 방법 보다,
처음부터 1을 빼고 10 - 9 - 3 - 1을 만드는 방법이 최솟값이다(-1을 하는 예외상황).
그렇기에 동적 계획법을 이용한다.

동적 계획법으로 1을 빼는 경우, 2로 나누는 경우, 3으로 나누는 경우 모든 경우의 수 중 최솟값을 찾아낼 수 있기 때문이다.


+아직 동적 계획법이 익숙하지 않아 대강 개념만 알고 있는 느낌이다. 문제를 통해 DP를 체화 시켜야겠다.
'''
